local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local Lighting = game:GetService("Lighting")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterGui = game:GetService("StarterGui")
local LP = Players.LocalPlayer

local function alive(i)
    if not i then return false end
    local ok = pcall(function() return i.Parent end)
    if not ok then return false end
    return i.Parent ~= nil
end

local function validPart(p)
    return p and alive(p) and p:IsA("BasePart")
end

local Window = Fluent:CreateWindow({
    Title = "Violence District",
    SubTitle = "by jlcfg",
    TabWidth = 160,
    Size = UDim2.fromOffset(660, 520),
    Acrylic = false,
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.LeftControl
})

local Tabs = {
    Player = Window:AddTab({ Title = "Player", Icon = "user" }),
    ESP = Window:AddTab({ Title = "ESP", Icon = "eye" }),
    World = Window:AddTab({ Title = "World", Icon = "map" }),
    Misc = Window:AddTab({ Title = "Misc", Icon = "wrench" }),
    Visual = Window:AddTab({ Title = "Visual", Icon = "sun" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "sliders" })
}

local function firstBasePart(inst)
    if not alive(inst) then return nil end
    if inst:IsA("BasePart") then return inst end
    if inst:IsA("Model") then
        if inst.PrimaryPart and inst.PrimaryPart:IsA("BasePart") and alive(inst.PrimaryPart) then return inst.PrimaryPart end
        local p = inst:FindFirstChildWhichIsA("BasePart", true)
        if validPart(p) then return p end
    end
    return nil
end

local function makeBillboard(text, color3)
    local g = Instance.new("BillboardGui")
    g.Name = "VD_Tag"
    g.AlwaysOnTop = true
    g.Size = UDim2.new(0, 180, 0, 34)
    g.StudsOffset = Vector3.new(0, 3, 0)
    local l = Instance.new("TextLabel")
    l.Name = "Label"
    l.BackgroundTransparency = 1
    l.Size = UDim2.new(1, 0, 1, 0)
    l.Font = Enum.Font.GothamBold
    l.Text = text
    l.TextSize = 14
    l.TextColor3 = color3 or Color3.new(1,1,1)
    l.TextStrokeTransparency = 0
    l.TextStrokeColor3 = Color3.new(0,0,0)
    l.Parent = g
    return g
end

local function ensureBoxESP(part, name, color)
    if not validPart(part) then return end
    local esp = part:FindFirstChild(name)
    if not esp then
        local ok, obj = pcall(function()
            local a = Instance.new("BoxHandleAdornment")
            a.Name = name
            a.Adornee = part
            a.ZIndex = 10
            a.AlwaysOnTop = true
            a.Transparency = 0.5
            a.Size = part.Size + Vector3.new(0.2,0.2,0.2)
            a.Color3 = color
            a.Parent = part
            return a
        end)
        if not ok then return end
        esp = obj
    else
        esp.Color3 = color
        esp.Size = part.Size + Vector3.new(0.2,0.2,0.2)
    end
end

local function clearChild(o, n)
    if o and alive(o) then
        local c = o:FindFirstChild(n)
        if c then pcall(function() c:Destroy() end) end
    end
end

local function ensureHighlight(model, fill)
    if not model or not model:IsA("Model") or not alive(model) then return end
    local hl = model:FindFirstChild("VD_HL")
    if not hl then
        local ok, obj = pcall(function()
            local h = Instance.new("Highlight")
            h.Name = "VD_HL"
            h.Adornee = model
            h.FillTransparency = 0.5
            h.OutlineTransparency = 0
            h.Parent = model
            return h
        end)
        if not ok then return end
        hl = obj
    end
    hl.FillColor = fill
    hl.OutlineColor = fill
    hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
end

local function clearHighlight(model)
    if model and model:FindFirstChild("VD_HL") then pcall(function() model.VD_HL:Destroy() end) end
end

local survivorColor = Color3.fromRGB(0,255,0)
local killerColor = Color3.fromRGB(255,0,0)
local nametagsEnabled = false
local playerESPEnabled = false
local playerConns = {}

local function getRole(p)
    if p.Team and p.Team.Name then
        local n = p.Team.Name:lower()
        if n:find("killer") then return "Killer" end
        if n:find("survivor") then return "Survivor" end
    end
    return "Survivor"
end

local function applyPlayerESP(p)
    if p == LP then return end
    local c = p.Character
    if not c or not alive(c) then return end
    local role = getRole(p)
    local col = role == "Killer" and killerColor or survivorColor
    if playerESPEnabled then
        if c:IsDescendantOf(Workspace) then ensureHighlight(c, col) end
        local head = c:FindFirstChild("Head")
        if nametagsEnabled and validPart(head) then
            if not head:FindFirstChild("VD_Tag") then
                local b = makeBillboard(p.Name, col)
                if alive(head) then b.Parent = head end
            else
                local l = head.VD_Tag:FindFirstChild("Label")
                if l then l.Text = p.Name l.TextColor3 = col end
            end
        elseif head and head:FindFirstChild("VD_Tag") then
            pcall(function() head.VD_Tag:Destroy() end)
        end
    else
        clearHighlight(c)
        local head = c:FindFirstChild("Head")
        if head and head:FindFirstChild("VD_Tag") then pcall(function() head.VD_Tag:Destroy() end) end
    end
end

local function watchPlayer(p)
    if playerConns[p] then for _,cn in ipairs(playerConns[p]) do cn:Disconnect() end end
    playerConns[p] = {}
    table.insert(playerConns[p], p.CharacterAdded:Connect(function()
        task.delay(0.15, function() applyPlayerESP(p) end)
    end))
    table.insert(playerConns[p], p:GetPropertyChangedSignal("Team"):Connect(function() applyPlayerESP(p) end))
    if p.Character then applyPlayerESP(p) end
end

local function unwatchPlayer(p)
    if p.Character then
        clearHighlight(p.Character)
        local head = p.Character:FindFirstChild("Head")
        if head and head:FindFirstChild("VD_Tag") then pcall(function() head.VD_Tag:Destroy() end) end
    end
    if playerConns[p] then for _,cn in ipairs(playerConns[p]) do cn:Disconnect() end end
    playerConns[p] = nil
end

local playerSec = Tabs.ESP:AddSection("Players")
playerSec:AddToggle("PlayerESP", { Title = "Player ESP (Chams)", Default = false, Callback = function(s)
    playerESPEnabled = s
    for _,pl in ipairs(Players:GetPlayers()) do if pl ~= LP then applyPlayerESP(pl) end end
end})
playerSec:AddToggle("Nametags", { Title = "Nametags", Default = false, Callback = function(s)
    nametagsEnabled = s
    for _,pl in ipairs(Players:GetPlayers()) do if pl ~= LP then applyPlayerESP(pl) end end
end})
playerSec:AddColorpicker("SurvivorCol", { Title = "Survivor Color", Default = survivorColor, Callback = function(c)
    survivorColor = c
    for _,pl in ipairs(Players:GetPlayers()) do if pl ~= LP then applyPlayerESP(pl) end end
end})
playerSec:AddColorpicker("KillerCol", { Title = "Killer Color", Default = killerColor, Callback = function(c)
    killerColor = c
    for _,pl in ipairs(Players:GetPlayers()) do if pl ~= LP then applyPlayerESP(pl) end end
end})

for _,p in ipairs(Players:GetPlayers()) do if p ~= LP then watchPlayer(p) end end
Players.PlayerAdded:Connect(watchPlayer)
Players.PlayerRemoving:Connect(unwatchPlayer)
local worldColors = {
    Generator = Color3.fromRGB(0,170,255),
    Hook = Color3.fromRGB(255,0,0),
    Gate = Color3.fromRGB(255,225,0),
    Window = Color3.fromRGB(255,255,255),
    Palletwrong = Color3.fromRGB(255,140,0)
}
local worldEnabled = {Generator=false,Hook=false,Gate=false,Window=false,Palletwrong=false}
local validCats = {Generator=true,Hook=true,Gate=true,Window=true,Palletwrong=true}
local worldReg = {Generator={},Hook={},Gate={},Window={},Palletwrong={}}
local mapAdd, mapRem = {}, {}
local worldLoopThread = nil

local function pickRep(model, cat)
    if not model or not alive(model) then return nil end
    if cat == "Generator" then
        local hb = model:FindFirstChild("HitBox", true)
        if validPart(hb) then return hb end
    elseif cat == "Palletwrong" then
        local a = model:FindFirstChild("HumanoidRootPart", true)
        if validPart(a) then return a end
        local b = model:FindFirstChild("PrimaryPartPallet", true)
        if validPart(b) then return b end
        local c = model:FindFirstChild("Primary1", true)
        if validPart(c) then return c end
        local d = model:FindFirstChild("Primary2", true)
        if validPart(d) then return d end
    end
    return firstBasePart(model)
end

local function ensureWorldEntry(cat, model)
    if not alive(model) then return end
    if worldReg[cat][model] then return end
    local rep = pickRep(model, cat)
    if not validPart(rep) then return end
    worldReg[cat][model] = {part = rep}
end

local function removeWorldEntry(cat, model)
    local entry = worldReg[cat][model]
    if not entry then return end
    local part = entry.part
    clearChild(part, "VD_"..cat)
    clearChild(part, "VD_Text_"..cat)
    worldReg[cat][model] = nil
end

local function registerFromDescendant(obj)
    if not alive(obj) then return end
    if obj:IsA("Model") and validCats[obj.Name] then
        ensureWorldEntry(obj.Name, obj)
        return
    end
    if obj:IsA("BasePart") and obj.Parent and obj.Parent:IsA("Model") and validCats[obj.Parent.Name] then
        ensureWorldEntry(obj.Parent.Name, obj.Parent)
    end
end

local function unregisterFromDescendant(obj)
    if not obj then return end
    if obj:IsA("Model") and validCats[obj.Name] then
        removeWorldEntry(obj.Name, obj)
        return
    end
    if obj:IsA("BasePart") and obj.Parent and obj.Parent:IsA("Model") and validCats[obj.Parent.Name] then
        if worldReg[obj.Parent.Name][obj.Parent] and worldReg[obj.Parent.Name][obj.Parent].part == obj then
            removeWorldEntry(obj.Parent.Name, obj.Parent)
        end
    end
end

local function attachRoot(root)
    if not root or mapAdd[root] then return end
    mapAdd[root] = root.DescendantAdded:Connect(registerFromDescendant)
    mapRem[root] = root.DescendantRemoving:Connect(unregisterFromDescendant)
    for _,d in ipairs(root:GetDescendants()) do registerFromDescendant(d) end
end

local function refreshRoots()
    for _,cn in pairs(mapAdd) do if cn then cn:Disconnect() end end
    for _,cn in pairs(mapRem) do if cn then cn:Disconnect() end end
    mapAdd, mapRem = {}, {}
    local r1 = Workspace:FindFirstChild("Map")
    local r2 = Workspace:FindFirstChild("Map1")
    if r1 then attachRoot(r1) end
    if r2 then attachRoot(r2) end
end

local function clearCategory(cat)
    for _,entry in pairs(worldReg[cat]) do
        if entry and entry.part then
            clearChild(entry.part, "VD_"..cat)
            clearChild(entry.part, "VD_Text_"..cat)
        end
    end
end

local function anyWorldEnabled()
    for _,v in pairs(worldEnabled) do if v then return true end end
    return false
end

local function startWorldLoop()
    if worldLoopThread then return end
    worldLoopThread = task.spawn(function()
        while anyWorldEnabled() do
            for cat,models in pairs(worldReg) do
                if worldEnabled[cat] then
                    local col = worldColors[cat]
                    local tagName = "VD_"..cat
                    local textName = "VD_Text_"..cat
                    local labelText = cat == "Palletwrong" and "Pallet" or cat
                    local n = 0
                    for model,entry in pairs(models) do
                        local part = entry.part
                        if model and alive(model) then
                            if not validPart(part) or not part:IsDescendantOf(model) then
                                entry.part = pickRep(model, cat)
                                part = entry.part
                            end
                            if validPart(part) then
                                ensureBoxESP(part, tagName, col)
                                local bb = part:FindFirstChild(textName)
                                if not bb then
                                    local newbb = makeBillboard(labelText, col)
                                    newbb.Name = textName
                                    if alive(part) then newbb.Parent = part end
                                else
                                    local lbl = bb:FindFirstChild("Label")
                                    if lbl then lbl.Text = labelText lbl.TextColor3 = col end
                                end
                            end
                        else
                            removeWorldEntry(cat, model)
                        end
                        n += 1
                        if n % 50 == 0 then task.wait() end
                    end
                end
            end
            task.wait(0.25)
        end
        worldLoopThread = nil
    end)
end

local function setWorldToggle(cat, state)
    worldEnabled[cat] = state
    if state then
        if not worldLoopThread then startWorldLoop() end
    else
        clearCategory(cat)
    end
end

refreshRoots()
Workspace.ChildAdded:Connect(function(ch)
    if ch.Name == "Map" or ch.Name == "Map1" then attachRoot(ch) end
end)

local worldSec = Tabs.World:AddSection("Toggles")
worldSec:AddToggle("Gen", { Title = "Generators", Default = false, Callback = function(s) setWorldToggle("Generator", s) end })
worldSec:AddToggle("Hook", { Title = "Hooks", Default = false, Callback = function(s) setWorldToggle("Hook", s) end })
worldSec:AddToggle("Gate", { Title = "Gates", Default = false, Callback = function(s) setWorldToggle("Gate", s) end })
worldSec:AddToggle("Window", { Title = "Windows", Default = false, Callback = function(s) setWorldToggle("Window", s) end })
worldSec:AddToggle("Pallet", { Title = "Pallets", Default = false, Callback = function(s) setWorldToggle("Palletwrong", s) end })

local worldCol = Tabs.World:AddSection("Colors")
worldCol:AddColorpicker("GenCol", { Title = "Generators", Default = worldColors.Generator, Callback = function(c) worldColors.Generator = c end })
worldCol:AddColorpicker("HookCol", { Title = "Hooks", Default = worldColors.Hook, Callback = function(c) worldColors.Hook = c end })
worldCol:AddColorpicker("GateCol", { Title = "Gates", Default = worldColors.Gate, Callback = function(c) worldColors.Gate = c end })
worldCol:AddColorpicker("WinCol", { Title = "Windows", Default = worldColors.Window, Callback = function(c) worldColors.Window = c end })
worldCol:AddColorpicker("PalCol", { Title = "Pallets", Default = worldColors.Palletwrong, Callback = function(c) worldColors.Palletwrong = c end })

local function hasAncestorNamed(instance, target)
    local p = instance and instance.Parent
    while p do
        if p.Name == target then return true end
        p = p.Parent
    end
    return false
end

local function isExactPalletStunRemote(inst)
    if not inst or not inst:IsA("RemoteEvent") then return false end
    local n = inst.Name
    if n ~= "Stun" and n ~= "Stunover" then return false end
    if not hasAncestorNamed(inst, "Pallet") then return false end
    if not hasAncestorNamed(inst, "Remotes") then return false end
    if not inst:IsDescendantOf(ReplicatedStorage) then return false end
    return true
end

local stunHookInstalled = false
local function installNonDestructiveStunHook()
    if stunHookInstalled then return end
    if typeof(hookmetamethod) == "function" and typeof(getnamecallmethod) == "function" then
        local old
        old = hookmetamethod(game, "__namecall", function(self, ...)
            local m = getnamecallmethod()
            if LP.Team and LP.Team.Name == "Killer" then
                if m == "FireServer" and typeof(self) == "Instance" and isExactPalletStunRemote(self) then
                    return nil
                end
            end
            return old(self, ...)
        end)
        stunHookInstalled = true
    end
end

task.spawn(function()
    installNonDestructiveStunHook()
end)
local guiWhitelist = {
    ["Fluent"] = true,
    ["DevConsoleMaster"] = true,
    ["RobloxGui"] = true,
    ["PlayerList"] = true,
    ["Chat"] = true,
    ["BubbleChat"] = true,
    ["Backpack"] = true
}

local skillExactNames = {
    SkillCheckPromptGui = true,
    ["SkillCheckPromptGui-con"] = true,
    SkillCheckEvent = true,
    SkillCheckFailEvent = true,
    SkillCheckResultEvent = true
}

local function isExactSkill(inst)
    local n = inst and inst.Name
    if not n then return false end
    if skillExactNames[n] then return true end
    if n:lower():find("skillcheck", 1, true) then return true end
    return false
end

local function hardDelete(obj)
    pcall(function()
        if obj:IsA("ProximityPrompt") then
            obj.Enabled = false
            obj.HoldDuration = 1e9
        end
        if obj:IsA("ScreenGui") or obj:IsA("BillboardGui") or obj:IsA("SurfaceGui") then
            if obj:IsA("ScreenGui") and guiWhitelist[obj.Name] then return end
            obj.Enabled = false
            obj.Visible = false
            obj.ResetOnSpawn = false
            obj:Destroy()
        else
            obj:Destroy()
        end
    end)
end

local function nukeSkillExactOnce()
    local pg = LP:FindFirstChild("PlayerGui")
    if pg then
        for _,g in ipairs(pg:GetChildren()) do if isExactSkill(g) then hardDelete(g) end end
        for _,d in ipairs(pg:GetDescendants()) do if isExactSkill(d) then hardDelete(d) end end
    end
    for _,g in ipairs(StarterGui:GetChildren()) do if isExactSkill(g) then hardDelete(g) end end
    local rem = ReplicatedStorage:FindFirstChild("Remotes")
    if rem then
        for _,d in ipairs(rem:GetDescendants()) do if isExactSkill(d) then hardDelete(d) end end
    end
end

local noSkillEnabled = false
local hookSkillInstalled = false
local rsAddConn, pgAddConn, pgDescConn, sgAddConn, remAddConn, wsAddConn
local charAddConns = {}

local function installSkillBlock()
    if hookSkillInstalled then return end
    if typeof(hookmetamethod)=="function" and typeof(getnamecallmethod)=="function" then
        local old
        old = hookmetamethod(game, "__namecall", function(self, ...)
            local m = getnamecallmethod()
            if noSkillEnabled and typeof(self)=="Instance" and isExactSkill(self) and (m=="FireServer" or m=="InvokeServer") then
                return nil
            end
            return old(self, ...)
        end)
        hookSkillInstalled = true
    end
end

local function startNoSkill()
    installSkillBlock()
    nukeSkillExactOnce()
    local pg = LP:FindFirstChild("PlayerGui")
    if pg then
        if pgAddConn then pgAddConn:Disconnect() end
        pgAddConn = pg.ChildAdded:Connect(function(ch)
            if noSkillEnabled and isExactSkill(ch) then hardDelete(ch) end
        end)
        if pgDescConn then pgDescConn:Disconnect() end
        pgDescConn = pg.DescendantAdded:Connect(function(d)
            if noSkillEnabled and isExactSkill(d) then hardDelete(d) end
        end)
    end
    if sgAddConn then sgAddConn:Disconnect() end
    sgAddConn = StarterGui.ChildAdded:Connect(function(ch)
        if noSkillEnabled and isExactSkill(ch) then hardDelete(ch) end
    end)
    local rem = ReplicatedStorage:FindFirstChild("Remotes")
    if rem then
        if remAddConn then remAddConn:Disconnect() end
        remAddConn = rem.DescendantAdded:Connect(function(d)
            if noSkillEnabled and isExactSkill(d) then hardDelete(d) end
        end)
    end
    if rsAddConn then rsAddConn:Disconnect() end
    rsAddConn = ReplicatedStorage.DescendantAdded:Connect(function(d)
        if not noSkillEnabled then return end
        if d:IsA("ScreenGui") or d:IsA("BillboardGui") or d:IsA("SurfaceGui") or d:IsA("RemoteEvent") or d:IsA("RemoteFunction") or d:IsA("BindableEvent") then
            if isExactSkill(d) then hardDelete(d) end
        end
    end)
    for _,pl in ipairs(Players:GetPlayers()) do
        if charAddConns[pl] then charAddConns[pl]:Disconnect() end
        charAddConns[pl] = pl.CharacterAdded:Connect(function(ch)
            if not noSkillEnabled then return end
            task.wait(0.1)
            for _,d in ipairs(ch:GetDescendants()) do if isExactSkill(d) then hardDelete(d) end end
        end)
        if pl.Character then
            for _,d in ipairs(pl.Character:GetDescendants()) do if isExactSkill(d) then hardDelete(d) end end
        end
    end
    if wsAddConn then wsAddConn:Disconnect() end
    wsAddConn = Workspace.DescendantAdded:Connect(function(d)
        if noSkillEnabled and isExactSkill(d) then hardDelete(d) end
    end)
end

local function stopNoSkill()
    if pgAddConn then pgAddConn:Disconnect() pgAddConn=nil end
    if pgDescConn then pgDescConn:Disconnect() pgDescConn=nil end
    if sgAddConn then sgAddConn:Disconnect() sgAddConn=nil end
    if remAddConn then remAddConn:Disconnect() remAddConn=nil end
    if rsAddConn then rsAddConn:Disconnect() rsAddConn=nil end
    if wsAddConn then wsAddConn:Disconnect() wsAddConn=nil end
    for pl,cn in pairs(charAddConns) do if cn then cn:Disconnect() end charAddConns[pl]=nil end
end

local miscSec = Tabs.Misc:AddSection("Skillcheck")
miscSec:AddToggle("NoSkill", {
    Title = "No Skillchecks",
    Default = false,
    Callback = function(s)
        noSkillEnabled = s
        if s then startNoSkill() else stopNoSkill() end
    end
})

local initLighting = {
    Brightness = Lighting.Brightness,
    ClockTime = Lighting.ClockTime,
    FogStart = Lighting.FogStart,
    FogEnd = Lighting.FogEnd,
    GlobalShadows = Lighting.GlobalShadows,
    OutdoorAmbient = Lighting.OutdoorAmbient,
    ExposureCompensation = Lighting.ExposureCompensation
}

local fullbrightEnabled = false
local fbLoop
local desiredClockTime = Lighting.ClockTime
local timeLockActive = false

local function bindTimeLock()
    if timeLockActive then return end
    timeLockActive = true
    RunService:BindToRenderStep("VD_TimeLock", 299, function()
        if Lighting.ClockTime ~= desiredClockTime then Lighting.ClockTime = desiredClockTime end
    end)
end

local function unbindTimeLock()
    if timeLockActive then
        timeLockActive = false
        pcall(function() RunService:UnbindFromRenderStep("VD_TimeLock") end)
    end
end

local visSec = Tabs.Visual:AddSection("Lighting")
visSec:AddToggle("Fullbright", { Title = "Fullbright", Default = false, Callback = function(s)
    fullbrightEnabled = s
    if fbLoop then task.cancel(fbLoop) fbLoop=nil end
    if s then
        fbLoop = task.spawn(function()
            while fullbrightEnabled do
                Lighting.Brightness = 2
                Lighting.ClockTime = 14
                Lighting.FogStart = 0
                Lighting.FogEnd = 1e9
                Lighting.GlobalShadows = false
                Lighting.OutdoorAmbient = Color3.fromRGB(128,128,128)
                Lighting.ExposureCompensation = 0
                task.wait(0.5)
            end
        end)
    else
        for k,v in pairs(initLighting) do pcall(function() Lighting[k]=v end) end
        desiredClockTime = Lighting.ClockTime
    end
end})
visSec:AddSlider("TimeOfDay", { Title = "Time Of Day", Min = 0, Max = 24, Default = Lighting.ClockTime, Rounding = 1, Callback = function(v)
    desiredClockTime = v
    Lighting.ClockTime = v
    bindTimeLock()
end })

local currentSpeed = 16
local speedHumanoid = nil
local speedConnChanged, speedConnAncestry = nil, nil
local speedBound = false

local function setWalkSpeed(h, v)
    if h and h.Parent then pcall(function() h.WalkSpeed = v end) end
end

local function bindSpeedLoop()
    if speedBound then return end
    speedBound = true
    RunService:BindToRenderStep("VD_SpeedEnforcer", 300, function()
        if not speedHumanoid or not speedHumanoid.Parent then return end
        if speedHumanoid.WalkSpeed ~= currentSpeed then setWalkSpeed(speedHumanoid, currentSpeed) end
    end)
end

local function unbindSpeedLoop()
    if speedBound then
        speedBound = false
        pcall(function() RunService:UnbindFromRenderStep("VD_SpeedEnforcer") end)
    end
end

local function hookHumanoid(h)
    if speedConnChanged then speedConnChanged:Disconnect() speedConnChanged=nil end
    if speedConnAncestry then speedConnAncestry:Disconnect() speedConnAncestry=nil end
    speedHumanoid = h
    setWalkSpeed(h, currentSpeed)
    bindSpeedLoop()
    speedConnChanged = h:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
        if h.Parent and h.WalkSpeed ~= currentSpeed then setWalkSpeed(h, currentSpeed) end
    end)
    speedConnAncestry = h.AncestryChanged:Connect(function(_, parent)
        if not parent then unbindSpeedLoop() end
    end)
end

local function onCharacterAdded(char)
    local h = char:WaitForChild("Humanoid", 10) or char:FindFirstChildOfClass("Humanoid")
    if h then hookHumanoid(h) end
    char.ChildAdded:Connect(function(ch) if ch:IsA("Humanoid") then hookHumanoid(ch) end end)
end

if LP.Character then onCharacterAdded(LP.Character) end
LP.CharacterAdded:Connect(onCharacterAdded)

local noclipEnabled = false
local noclipConn = nil
local noclipTouched = {}

local function setNoclip(state)
    if state and not noclipConn then
        noclipEnabled = true
        noclipConn = RunService.Stepped:Connect(function()
            local c = LP.Character
            if not c then return end
            for _,part in ipairs(c:GetDescendants()) do
                if part:IsA("BasePart") then
                    if part.CanCollide and not noclipTouched[part] then
                        noclipTouched[part] = true
                    end
                    part.CanCollide = false
                end
            end
        end)
    elseif not state and noclipConn then
        noclipEnabled = false
        noclipConn:Disconnect()
        noclipConn = nil
        for part,_ in pairs(noclipTouched) do
            if part and part.Parent then part.CanCollide = true end
        end
        noclipTouched = {}
    end
end

local playerMove = Tabs.Player:AddSection("Movement")
playerMove:AddSlider("WalkSpeed", { Title = "Walk Speed", Min = 0, Max = 200, Default = 16, Rounding = 0, Callback = function(v)
    currentSpeed = v
    if speedHumanoid and speedHumanoid.Parent then setWalkSpeed(speedHumanoid, currentSpeed) end
    bindSpeedLoop()
end})
playerMove:AddButton({ Title = "Reset Speed", Callback = function()
    currentSpeed = 16
    if speedHumanoid and speedHumanoid.Parent then setWalkSpeed(speedHumanoid, currentSpeed) end
end})
playerMove:AddToggle("Noclip", { Title = "Noclip", Default = false, Callback = function(s)
    setNoclip(s)
end})

LP.CharacterAdded:Connect(function()
    if noclipEnabled then task.wait(0.2) setNoclip(true) end
end)

SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({})
InterfaceManager:SetFolder("VD_Suite")
SaveManager:SetFolder("VD_Suite/config")
InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)
SaveManager:LoadAutoloadConfig()

Fluent:Notify({ Title = "Violence District", Content = "Loaded", Duration = 6 })
Window:SelectTab(3)
